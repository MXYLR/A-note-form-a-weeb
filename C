### 1. 正负号的运算优先级要高于乘除法, 其他运算符的优先级可以去查表.
### 2. 递增运算符
  - 前缀模式, 例如`q = 2 * ++a`
    - 首先 a 递增 1
    - 然后 2 乘以 a, 并将结果赋值给 q
  - 后缀模式, 例如`q = 2 * a++`
    - 首先, 2 乘以 a, 并将结果赋值给 q
    - 然后, a 递增 1
  - 单独使用递增运算符时, 前缀和后缀都一样
  - 递增和递减运算符只能影响一个变量, 即影响一个可修改的左值
  - 递增和递减运算符具有相当高的运算优先级, 仅次于圆括号()
```
百度百科 : <br/>
当递增或递减运算符放在其运算变量前面进行**前置运算**时，C 语言在使用**该变量之前**进行递增或递减操作, 就是 " 先递增再运算 "; <br/>
如果运算符在运算变量的后面进行**后置运算**，那么，C 语言在使用**运算变量的值之后**执行递增或递减运算, 就是 " 先运算再递增 ".
```
### 3.发现自己老是忘记这个, 还是写上吧.
scanf()函数
- 描述
C 库函数 int scanf(const char *format, ...) 从标准输入 stdin 读取格式化输入。

- 声明
下面是 scanf() 函数的声明。

int scanf(const char *format, ...)
- 参数
format -- 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。
format 说明符形式为 [=%[*][width][modifiers]type=]，具体讲解如下：
- 参数	描述
*	这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。
width	这指定了在当前读取操作中读取的最大字符数。
modifiers	为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）
type	一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格。
scanf 类型说明符：

- 类型	合格的输入	参数的类型
c	单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。	char *
d	十进制整数：数字前面的 + 或 - 号是可选的。	int *
e,E,f,g,G	浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4	float *
o	八进制整数。	int *
s	字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。	char *
u	无符号的十进制整数。	unsigned int *
x,X	十六进制整数。	int *
 -附加参数 
 -- 根据不同的 format 字符串，函数可能需要一系列的附加参数，
 每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。
-返回值
如果成功，该函数返回**成功匹配和赋值的个数**。如果到达文件末尾或发生读错误，则返回 EOF。
### 4.对 C 而言, 表达式为真的值是 1, 表达式为假的值是 0. 其实所有不是 0 的值都被视为真.
- _Bool 类型的变量只能储存 1(真) 或 0(假). 如果把其他非零数值赋给 _Bool 类型变量, 该变量会被设置为 1. 这反映了 C 会把所有的非零值都视为真.
- C99 提供了 <stdbool.h> 头文件, 该头文件让 bool 成为 _Bool 的别名, 而且还把 true 和 false 分别定义为 1 和 0 的符号常量.
