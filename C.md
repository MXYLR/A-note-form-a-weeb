### 1. 正负号的运算优先级要高于乘除法, 其他运算符的优先级可以去查表.

### 2. 递增运算符
  - 前缀模式, 例如`q = 2 * ++a`
    - 首先 a 递增 1
    - 然后 2 乘以 a, 并将结果赋值给 q
  - 后缀模式, 例如`q = 2 * a++`
    - 首先, 2 乘以 a, 并将结果赋值给 q
    - 然后, a 递增 1
  - 单独使用递增运算符时, 前缀和后缀都一样
  - 递增和递减运算符只能影响一个变量, 即影响一个可修改的左值
  - 递增和递减运算符具有相当高的运算优先级, 仅次于圆括号()

*百度百科* : 
当递增或递减运算符放在其运算变量前面进行**前置运算**时，C 语言在使用**该变量之前**进行递增或递减操作, 就是 " 先递增再运算 "; 
如果运算符在运算变量的后面进行**后置运算**，那么，C 语言在使用**运算变量的值之后**执行递增或递减运算, 就是 " 先运算再递增 ".


### 3.发现自己老是忘记这个, 还是写上吧.
scanf()函数
- 描述
C 库函数 int scanf(const char *format, ...) 从标准输入 stdin 读取格式化输入。

- 声明
下面是 scanf() 函数的声明。

int scanf(const char *format, ...)
- 参数
format -- 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。
format 说明符形式为 [=%[*][width][modifiers]type=]，具体讲解如下：
- 参数	描述
*	这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。
width	这指定了在当前读取操作中读取的最大字符数。
modifiers	为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）
type	一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格。
scanf 类型说明符：

- 类型	合格的输入	参数的类型
c	单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。	char *
d	十进制整数：数字前面的 + 或 - 号是可选的。	int *
e,E,f,g,G	浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4	float *
o	八进制整数。	int *
s	字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。	char *
u	无符号的十进制整数。	unsigned int *
x,X	十六进制整数。	int *
 -附加参数 
 -- 根据不同的 format 字符串，函数可能需要一系列的附加参数，
 每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。
-返回值
如果成功，该函数返回**成功匹配和赋值的个数**。如果到达文件末尾或发生读错误，则返回 EOF。

### 4.对 C 而言, 表达式为真的值是 1, 表达式为假的值是 0. 其实所有不是 0 的值都被视为真.
- _Bool 类型的变量只能储存 1(真) 或 0(假). 如果把其他非零数值赋给 _Bool 类型变量, 该变量会被设置为 1. 这反映了 C 会把所有的非零值都视为真.
- C99 提供了 <stdbool.h> 头文件, 该头文件让 bool 成为 _Bool 的别名, 而且还把 true 和 false 分别定义为 1 和 0 的符号常量.

### 5.逗号运算符
- 首先, 它保证了被它分隔的表达式从左往右求值, 换句话说就是逗号是一个序列点, 所以逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生.
- 其次, 整个逗号表达式的值是右侧项的值.
```
a = 249, 250; // a = 249 是逗号左侧的表达式, 250 是逗号右侧的表达式.
// 所以这句代码等于 :
a = 249 ;
250 ;
```
- 另外, 逗号也可以用作分隔符, 下面语句中的逗号都是分隔符, 而不是运算符 :
```      
      char ch, date;
      printf("%d %d\n", chimps, chumps);
```      
### 6.考虑到运行的速度, C 编译器不会检查数组的下标是否正确. 如果下标越界, 编译器不会查找这样的错误, 而这会导致数据被放置到已经被其他数据占用的地方 ( 栈顶超界 ),
这可能导致程序崩溃.


### 7.%格式说明:
%[flags][width][.perc][F|N|h|l]type
####1.type含义如下：　　
d有符号10进制整数　　
i有符号10进制整数　　
o无符号8进制整数　　
u无符号10进制整数　　
x无符号的16进制数字，并以小写abcdef表示　　
X无符号的16进制数字，并以大写ABCDEF表示　　
F/f浮点数　　
E/e用科学表示格式的浮点数　　
g使用%f和%e表示中的总的位数表示最短的来表示浮点数G同g格式，但表示为指数　　
c单个字符　　
s字符串　　
%显示百分号本身　　
p显示一个指针，near指针表示为：XXXX　　far指针表示为：XXXX：YYYY　　
n相连参量应是一个指针，其中存放已写字符的个数　　
####2.flags规定输出格式，取值和含义如下：　　
无右对齐，左边填充0和空格　　
-左对齐，右边填充空格　　
+在数字前增加符号+或-　　
0将输出的前面补上0，直到占满指定列宽为止（不可以搭配使用-）　　
空格输出值为正时冠以空格，为负时冠以负号　　
#当type=c,s,d,i,u时没有影响　　
type=o,x,X时，分别在数值前增加'0',"0x","0X"　　
type=e,E,f时，总是使用小数点　　
type=g,G时，除了数值为0外总是显示小数点　　
####3.width用于控制显示数值的宽度，取值和含义如下　　
n(n=1,2,3)宽度至少为n位，不够以空格填充　　
0n(n=1,2,3)宽度至少为n位，不够左边以0填充　　
*格式列表中，下一个参数还是width　　
####4.prec用于控制小数点后面的位数，取值和含义如下：　　
无按缺省精度显示　　
0当type=d,i,o,u,x时，没有影响　　
type=e,E,f时，不显示小数点　　
n(n=1,2,3)当type=e,E,f时表示的最大小数位数　　
type=其他，表示显示的最大宽度　　
.*格式列表中，下一个参数还是width　　
####5.F|N|h|l表示指针是否是远指针或整数是否是长整数　　
F远指针　　n近指针　　h短整数或单精度浮点数　　l长整数或双精度浮点数

### 8._下划线被看作是字母, 变量名必须以字母开头, 所以下划线可以用作变量名开头以提高可读性.

### 9. 枚举类型 : https://www.cnblogs.com/JCSU/articles/1299051.html

### 10.指针数组和数组指针的区别

- 指针数组

指针数组：指针数组可以说成是”指针的数组”，首先这个变量是一个数组。

其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型。

在 32 位系统中，指针占四个字节。

- 数组指针

数组指针：数组指针可以说成是”数组的指针”，首先这个变量是一个指针。

其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。

- 根据上面的解释，可以了解到指针数组和数组指针的区别，因为二者根本就是不同种类型的变量。
